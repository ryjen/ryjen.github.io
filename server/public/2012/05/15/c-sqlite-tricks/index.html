<!doctype html>
<html class="no-js" lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>C Sqlite Tricks</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

        <meta name="description" content="The fortunes api serves witty antidotes from the UNIX world that relieve project tensions.">
    <meta name="keywords" content="unix,fortunes,micrantha,ryjen,ryan,jennings,coda,humour,humor,micro,microservice,micro-service,api,poems,proverbs,cookie,definitions,joke">
    <link rel="manifest" href="site.webmanifest">
    <link rel="apple-touch-icon" href="/icon/icon.png">

    
<link rel="stylesheet" href="/css/normalize.css">
<link rel="stylesheet" href="/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/skeleton.css">
<link href="https://fonts.googleapis.com/css?family=Inconsolata|Lora|Raleway" rel="stylesheet">
<style type="text/css">

#header {
	
    background-color: mediumseagreen;
    

    
    color: whitesmoke;
    
    
}

</style>

<link rel="stylesheet" href="/css/main.css">



 

    <meta name="generator" content="Hugo 0.35" />

</head>
<body>



<div id="header" class="clearfix">
    
    <div class="container clearfix">
        <span id="menu-toggle">&equiv;</span>
        <div id="brand">
			<a href="/">
	<img src="/image/logo-light.svg" alt="logo" width="40" height="40" /> <span>coda life</span>
</a>

        </div>
        <nav>
            
                <ul class="nav navbar-nav">
                    
                        <li class="nav-toggle blog">
                            
                            <i class="fa fa-rss"></i> 
                            
                            <a href="/post">blog</a>
                        </li>
                    
                        <li class="nav-toggle music">
                            
                            <i class="fa fa-music"></i> 
                            
                            <a href="/music">music</a>
                        </li>
                    
                        <li class="nav-toggle things">
                            
                            <i class="fa fa-object-ungroup"></i> 
                            
                            <a href="/things">things</a>
                        </li>
                    
                </ul>
            


            
                <ul class="nav navbar-icons">
                    
                        <li class="navbar-icon"><a href="mailto:ryan@coda.life"><i class="fa fa-envelope-o"></i></a></li>
                    
                        <li class="navbar-icon"><a href="https://github.com/ryjen/"><i class="fa fa-github"></i></a></li>
                    
                </ul>
            
        </nav>
    </div>
</div>

<div class="container">


<div id="main">

	<h2>C Sqlite Tricks</h2>

    <div class="text-justify"><p>Well, I thought I would share some tricks I use for easy data CRUD&rsquo;s in C (potentially C++/ObjC but its lacking typesafety).  I&rsquo;m using sqlite here, but could apply to any database.</p>

<p>This is how my data access works - I&rsquo;m not saying its the best approach, its just how its evolved for me.</p>

<pre><code class="language-c">    /* The account table name */
    #define ACCOUNT_TABLE &quot;account&quot;

    /* a structure representing the account fields */
    field_map account_values[] = {
      {&quot;login&quot;, &amp;acc-&gt;login, SQL_TEXT},
      {&quot;email&quot;, &amp;acc-&gt;email, SQL_TEXT},
      {&quot;password&quot;, &amp;acc-&gt;password, SQL_TEXT},
      {&quot;timezone&quot;, &amp;acc-&gt;timezone, SQL_INT},
      {0}
    };

    /* saves the fields to the database */
    acc-&gt;id = db_save(account_values, ACCOUNT_TABLE, acc-&gt;id);
</code></pre>

<p>As you can see, saving a structure is as simple as creating a field_map table and calling db_save.</p>

<pre><code class="language-c">   /* loads one account by id
    * the query results are assigned to the pointers in the table
    */
    if(db_load_by_id(account_values, ACCOUNT_TABLE, acc-&gt;id) != SQL_OK)
      fprintf(stderr, &quot;could not load account&quot;);

    /* a callback method */
    void load_account_callback(sql_stmt *stmt);

    /* load all accounts using the callback method
     * query results are sent to the callback
     */
    if(db_load_all(ACCOUNT_TABLE, load_account_callback) != SQL_OK)
      fprintf(stderr, &quot;could not load accounts&quot;);
</code></pre>

<p>Loading is the same for single instances, but I use a callback method to load multiple instances.</p>

<p>The core of my data access is the field_map structure, which determines how to save each field to the database.</p>

<pre><code class="language-c">    /*
     * this is the magical table used to communicate between memory and the database
     */
    typedef struct field_map {
      const char   *name;        /* name of the field */
      void        *value;        /* a pointer to the value of the field */
      int         type;          /* type of value */
      const void   *arg1;        /* additional argument */
      const void   *arg2;        /* additional argument */
      int         flags;         /* usage flags */
    } field_map;

    /* callback for custom field types */
    typedef int (*custom_field_t) (sql_stmt *, int column, field_map *field);

    typedef void (*sql_callback_t) (sql_stmt *);
</code></pre>

<p>The implementations for save/load are basically just wrappers for the actual insert/update/select query methods.</p>

<pre><code class="language-c">    /**
     * saves a field_map.  does an insert/update based on id == 0
     */
    sql_int64 db_save(field_map * table, const char *tableName, sql_int64 id)
    {
      if (id == 0) {
        if (sql_insert_query(table, tableName) != SQL_OK)
            fprintf(stderr, &quot;could not insert to %s&quot;, tableName);
        return db_last_insert_rowid();
      } else {
        if (sql_update_query(table, tableName, id) != SQL_OK)
            fprintf(stderr, &quot;could not update %s&quot;, tableName);

        return id;
      }
    }

    /**
    * loads a field_map.
    * @param baseData is the base structure used in the field_map
    * @param table the field_map
    * @param tableName the name of the table
    * @param alloc the callacbk to create a new instance of data structure
    * @param on_load callback when a row has been loaded
    * @param constraints contraints for the sql query
    */
    int db_load_all(const char *tableName, sql_callback_t callback, const char *constraints, ...)
    {
      char buf[1024] = {0};

      if(constraints) {
        va_list args;

        va_start(args, constraints);

        vsnprintf(buf, sizeof(buf), constraints, args);

        va_end(args);
      }

      if (sql_select_query(0, tableName, callback, buf) != SQL_OK) {
        fprintf(stderr, &quot;could not load from %s&quot;, tableName);
        return 0;
      }

      return 1;
    }

    /**
     * loads a field_map by id.  Data will be loaded to the base structure used in the field_map table.
     */
    int db_load_by_id(field_map *table, const char *tablename, sql_int64 id)
    {
      char buf[1024] = {0};

      sprintf(buf, &quot;where %s='%lld'&quot;, tablenameid(tablename), id);

      if(sql_select_query(0, table, tablename, 0, buf) != SQL_OK) {
        fprintf(stderr, &quot;could not load from %s&quot;, tablename);
        return 0;
      }

      return 1;
    }
</code></pre>

<p>Nothing too crazy there, except for the sql_select_query parameters which I&rsquo;ll get to later.</p>

<p>We have to have a way to bind the field_map to the queries, so the following implementations take care of that:</p>

<pre><code class="language-c">    /**
     * binds a single field_map value to a query
     */
    int sql_bind_table_value(sql_stmt * stmt, int column, field_map * field)
    {
      if (field-&gt;value == 0) {
        return sql_bind_null(stmt, column);
      }
      switch (field-&gt;type) {
      case SQL_INT:
        return sql_bind_int(stmt, column, *((int*) field-&gt;value));
      case SQL_TEXT:
        {
            const char *str = *((const char *) field-&gt;value);
            return sql_bind_text(stmt, column, str, strlen(str), 0);
        }
      case SQL_DOUBLE:
        return sql_bind_double(stmt, column, *((double*) field-&gt;value));
      case SQL_FLOAT:
        return sql_bind_float(stmt, column, *((float*) field-&gt;value));
      case SQL_CUSTOM:
        {
            custom_sql func = (custom_sql) (field-&gt;arg1);
            assert(func != 0);
            return (*func) (stmt, column, field);
        }
      default:
        fprintf(stderr, &quot;unknown save type for field %s&quot;, field-&gt;name);
        return SQL_NONTYPE;
      }
    }

    /**
     * binds a field_map values to a query
     */
    int sql_bind_values(sql_stmt * stmt, field_map * table)
    {
      for (int i = 0; table[i].name != 0; i++) {
        int err = sql_bind_table_value(stmt, i + 1, &amp;table[i]);

        if (err != SQL_OK)
            return err;
      }

      return SQL_OK;
    }
</code></pre>

<p>Note: I use SQL_FLOAT and SQL_DOUBLE, they both point to SQLITE3_FLOAT, however when casting we need to know the actual type.</p>

<p>Now for the query methods.  They try to follow the same basic principle - create the query, bind the values, execute</p>

<pre><code class="language-c">    /**
     * insert query using a field_map
     */
    int sql_insert_query(field_map * table, const char *tablename)
    {
      sql_stmt *stmt;
      char buf[1024] = { 0 };
      char columns[1024] = { 0 };
      char params[1024] = { 0 };
      int i, len;

      for (i = 0; table[i].name != 0; i++) {
        strcat(columns, table[i].name);
        strcat(params, &quot;?&quot;);

        if (table[i + 1].name != 0) {
            strcat(columns, &quot;,&quot;);
            strcat(params, &quot;,&quot;);
        }
      }

      len =  sprintf(buf, &quot;insert into %s (%s) values(%s)&quot;, tablename, columns,
            params);

      if (sql_query(buf, len, &amp;stmt) != SQL_OK) {
        return sql_finalize(stmt);
      }

      if (sql_bind_values(stmt, table) != SQL_OK) {
        return sql_finalize(stmt);
      }

      /* execute */
      sql_step(stmt);

      return sql_finalize(stmt);
    }

    /**
     * updates query using a field_map
     */
    int sql_update_query(field_map * table, const char *tablename, sql_int64 id)
    {
      sql_stmt *stmt;
      char buf[1024] = { 0 };
      char params[1024] = { 0 };
      int i, len;

      for (i = 0; table[i].name != 0; i++) {
        strcat(params, table[i].name);
        strcat(params, &quot;=?&quot;);

        if (table[i + 1].name != 0) {
            strcat(params, &quot;,&quot;);
        }
      }

      len = sprintf(buf, &quot;update %s set %s where %s=%&quot; PRId64, tablename,
              params, tablenameid(tablename), id);

      if (sql_query(buf, len, &amp;stmt) != SQL_OK) {
        return sql_finalize(stmt);
      }

      if (sql_bind_values(stmt, table) != SQL_OK)
        return sql_finalize(stmt);

      /* execute */
      sql_step(stmt);

      return sql_finalize(stmt);
    }
</code></pre>

<p>The select query is simplified by having a callback for custom loading.  You can however use a field_map table to load a single instance.</p>

<pre><code class="language-c">    /**
     * we have a pointer to a field value, so if we do pointer math we can apply the field value to
     * structures of the same type/size.  Thats what the optional base/data parameters are for.
     */
    void sql_load_columns(sql_stmt *stmt, int i, field_map *field)
    {
      switch (field-&gt;type) {
      case SQL_INT:
          field_value(int, field, base, data) =  sql_column_int(stmt, i);
          break;
      case SQL_TEXT:
          field_value(const char *, field, base, data) = str_dup(sql_column_str(stmt, i));
          break;
      case SQL_FLOAT:
          field_value(float, field, base, data) = sql_column_float(stmt, i);
          break;
      case SQL_DOUBLE:
          field_value(double, field, base, data) = sql_column_double(stmt, i);
          break;
      case SQL_CUSTOM:
          {
              custom_sql *func =  (custom_sql *) field-&gt;arg1;
              assert(func != 0);
              (*func) (stmt, i, field);
              break;
          }
      }
    }

    /**
     * create the select query and step through the results using callbacks
     */
    int sql_select_query(field_map * table, const char *tablename, sql_callback_t callback, const char *constraints)
    {
      sql_stmt *stmt;
      char buf[1024] = { 0 };
      char columns[1024] = { 0 };
      int i, len;

      for (i = 0; table[i].name != 0; i++) {
          strcat(columns, table[i].name);

          if (table[i + 1].name != 0) {
              strcat(columns, &quot;,&quot;);
          }
      }

      len = sprintf(buf, &quot;select %s,%s from %s %s&quot;,
                tablenameid(tablename), columns,
                tablename,
                constraints ? constraints : &quot;&quot;);

      if (sql_query(buf, len, &amp;stmt) != SQL_OK) {
          return sql_finalize(stmt);
      }
      for (err = sql_step(stmt); err != SQL_DONE; err = sql_step(stmt)) {

          /* check for a table to load */
          for (int i = 0; table &amp;&amp; table[i].name != 0; i++) {

              sql_load_columns(stmt, i+2, &amp;table[i]);
          }

          /* check for a callback */
          if(callback) {
              callback(stmt);
          }
      }
      return sql_finalize(stmt);
    }
</code></pre>

<p>There are still some utility functions and defines used throughout this code.  There is a lot of cleanup and error checking to do here as well.   But you should get the general idea.</p>
</div>

</div>

</div>





<hr>

<div class="container">


    <div id="related">
        <h5>Related:</h5>

         <div class="card item bg-default clearfix">

    
    

      

    <p class="pull-right">November 27, 2016</p>
    <h4><a href="/2016/11/27/microsoft-dev-stack-on-macos/">Microsoft Dev Stack on macOS</a></h4>
    <h5>a microsoft cross-platform mobile and cloud first development stack on macOS</h5>

     <span class="item-tag">development</span>  <span class="item-tag">programming</span>  <span class="item-tag">cross platform</span>  <span class="item-tag">mobile</span>  <span class="item-tag">web</span> 

</div>
  <div class="card item bg-default clearfix">

    
    

      

    <p class="pull-right">November 30, 2012</p>
    <h4><a href="/2012/11/30/poor-mans-polymorphism/">Poor Man&#39;s Polymorphism</a></h4>
    <h5>hacking in c</h5>

     <span class="item-tag">c</span>  <span class="item-tag">polymorphism</span>  <span class="item-tag">programming</span> 

</div>
 

    </div>


</div>



<hr>

<div class="container">

	
	  <div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "arg3" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
	

</div>


</div>

<div class="center">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
    <ins class="adsbygoogle"
         style="display:block"
         data-ad-client="ca-pub-5084920929867043"
         data-ad-slot="3126644849"
         data-ad-format="auto"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>


<hr>




<footer class="center">
	&copy; all rights reserved, ryan jennings
</footer>


    <script src="/js/vendor/modernizr-3.5.0.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/vendor/jquery-3.2.1.min.js"><\/script>')</script>
<script src="/js/plugins.js"></script>
<script src="/js/main.js"></script>





 


</body>
</html>

