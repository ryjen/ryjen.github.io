---
title: Software Methodologies
description: explaining software engineering methodologies for the layman
date: 2020-08-20
tags: [software, process, methodology, development]
categories: [engineering]
---

At the end of the day, software methodologies is all some form of [Development Lifecycle](https://en.wikipedia.org/wiki/Systems_development_life_cycle).

That is to say, the *individuals* unit of work, the *team's* unit of work and the *business*, are in one of several stages.

### Software Development Life Cycle
1. Requirements and Planning
2. Analysis and Design
3. Implementation
4. Testing and Verification
5. Deployment and Integration
7. Maintenance and Evolution

That is it.  We all know it. The steps may vary but the core ones remain the same.

## Methodologies

The **methodology** describes how you use the SDLC.  Typically:

1. How often you iterate
2. How other disciplines and teams claim a stake
3. What frameworks or practices are used

There are 3 main methodologies to use as an example.

### [Waterfall](https://en.wikipedia.org/wiki/Waterfall_model)

Each step in the SDLC is done only **once and completely** with a finished system at the end. 

Department members who are not actively participating in outputs are providing input (usually meetings) to make the stage as successful as it can be.

Participants may require a lot of experience to foresee a successful stage. 

Turned out to be a very naive approach due to the difficulty of making changes.

Probably has roots in hardware where the final result is not as mutable as software.  You may still see the process in such companies.

I have worked in waterfall where the complete manual was handed to our team before implementation.

### [Iterative](https://en.wikipedia.org/wiki/Iterative_and_incremental_development)

The idea with this approach is to *improve the cost of changes*.

To develop a complete system, the stages of the SDLC are *repeated in iterations* or increments.

Unknown complexities are learned quicker and re-incorporated back into the process in the next iteration.

Resources spent on each iteration are focused, modular, and done with less.

Even with no changes in requirements, the knowledge gained from each iteration helps the next one.

An iteration length varies with the project.  NASA used ~8 week iterations.  I have worked in ~4 week iterations.

### [Unified Process](https://en.wikipedia.org/wiki/Unified_Process)

The unified process expands on the iterative methodology.  It defines four **phases** during multiple iterations.

The phases are aimed at addressing risk for project management.  

The **framework** allows for a reliable view of operations for the business quarter cycle.

Each phase has project **goals** that include different stages in the SDLC for input. 

The benefit of a phased approach is that cross-discipline teams have their stakes accounted for during a time period.

#### Inception phase

Determines feasibility and estimates. Lasts ~1 iteration involving requirements and analysis stages.

#### Elaboration phase

Produces a milestone of captured requirements, validated architecture, and addressed risk.
Lasts ~2 iterations involving requirements, analysis, implementation, and testing stages.

#### Construction

Produces a release each iteration. Lasts ~4 iterations involving analysis, implementation, and testing stages.

#### Transition

Produces a final production release and maintenance. Lasts ~2 iterations involving testing and deployment stages.


### [Agile](https://en.wikipedia.org/wiki/Agile_software_development)

The practice of software engineering evolved in the late 20th and 21st century, with more people, better internet, memory, speed and tools.

Mitigating risk so aggressively became less of a need to some and desired to be less mundane.

A **simplified unified process** was desired to improve productivity.  The [manifesto for agile development](https://en.wikipedia.org/wiki/Agile_software_development#The_Agile_Manifesto) was popularized as a way forward.

The agile manifesto declares values like:

* people and communication over processes and tools
* working software over manuals
* customer collaboration over contracts
* adaptability over a plan

Agile development is typically shorter iterations of the SDLC around 1 or 2 weeks.

Shorter iterations in agile allow risk management as either **adaptive ephemeral milestones**, or **predictive analysis**.

Agile methodologies incorporate frameworks and practices like:

* [Scrum](https://en.wikipedia.org/wiki/Scrum_(software_development)): defines team roles, workflows and project artifacts
* [Kanban](https://en.wikipedia.org/wiki/Kanban_(development)): visualized capacity tasks instead of requested tasks
* [Continuous Integration](https://en.wikipedia.org/wiki/Continuous_integration): automated unit test verification
* [Test Driven Development](https://en.wikipedia.org/wiki/Test-driven_development): writing tests before implementation
* [Retrospectives](https://en.wikipedia.org/wiki/Retrospective) and [Daily Standups](https://en.wikipedia.org/wiki/Stand-up_meeting): humanized meetings

I have worked in ~1.5 week agile and in my honest opinion, it is a very construction phase oriented methodology lacking emphasis on design and verification on complex solutions as a whole.

## Next?

Software engineering sees another increase of people and transition of experience to managerial type roles in its next evolution.

All have high hopes of fame and greater riches.  How do businesses manage such expectations?  How do managerial type roles satisfy the needs of technical people?

One answer is, satirically, with an *increase of methodology complexity*.

Think of the benefits:

1. Satisfy the complexity equals knowledge work cash syndrome for the non-technical
2. Transform engineering into a point based statistical game for political gain
3. Turn fatigued people relationships into competition
4. Delay ambitious promotions for longevity
5. A revolving door of humans to keep actual work tasks simple

Or a few alternates:

2. Mature as a profession like accounting with oversight and regulatory associations
3. Teach Artificial Intelligence how to develop software

### The shadow

If you have experience developing software in the industry you will know that even the most passionate engineer will turn to a bitter vegetable. 

When all your human interactions involve being reduced to a means to an end, your challenges are only problems you did not create, no amount of methodology or team spirit will save you.

## Out

For me, its pure.  It is simple.  It is about quality, it is about cost and it is about time.  You cannot have your cake and eat it too.

The easiest way to achieve all three is still by iterating the same damn gobbledy gook (SDLC) every damn day.

To find meaning in it is to accept it as it is, and do as efficiently as one would assemble in a factory.

